% \documentclass{ceurart}
\documentclass{easychair}

%----CEUR style
%% One can fix some overfulls
\sloppy

%----My style
% \usepackage{doc}
\usepackage{setspace}
\usepackage{verbatim}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{upquote}
\renewcommand\UrlFont{\color{blue}\rmfamily}

%----Making things more compact
\newcommand{\smalltt}[1]{\small \texttt{#1}}
\newenvironment{packed_itemize}{
\vspace*{-0.3em}
\begin{itemize}
\setlength{\partopsep}{0pt}
\setlength{\itemsep}{1pt}
\setlength{\parskip}{0pt}
\setlength{\parsep}{0pt}
}{\end{itemize}}
\newenvironment{packed_enumerate}{
\vspace*{-0.3em}
\begin{enumerate}
\setlength{\partopsep}{0pt}
\setlength{\itemsep}{1pt}
\setlength{\parskip}{0pt}
\setlength{\parsep}{0pt}
}{\end{enumerate}}
%----Suppress extra space in texttt mode
\AddToHook{cmd/ttfamily/after}{\frenchspacing}
% \renewcommand{\arraystretch}{0.8}
\renewcommand{\floatpagefraction}{0.9}
\renewcommand{\textfloatsep}{2.0ex}
% \setlength{\floatsep}{2.0pt plus 2.0pt minus 2.0pt}
% \setlength{\textfloatsep}{5.0pt plus 2.0pt minus 0.0pt}
\renewcommand{\dbltextfloatsep}{2.0ex}
% \renewcommand{\textfraction}{0.07}
% \renewcommand{\topfraction}{0.9}
% \renewcommand{\bottomfraction}{0.9}
\setlength{\tabcolsep}{3pt}

\newcommand{\alex}[1]{{\color{red}{{#1}}}}

%----CEUR style
% \begin{document}
% \copyrightyear{2024}
% \copyrightclause{Copyright for this paper by its authors.
%   Use permitted under Creative Commons License Attribution 4.0 International (CC BY 4.0).}
% \conference{The 9th Workshop on Practical Aspects of Automated Reasoning,
%   July 2, 2024, Nancy, France}
% \title{The New TPTP Format for Interpretations}
% 
% \author[1]{Geoff Sutcliffe}[%
% orcid=0000-0001-7116-9338,
% email=geoff@cs.miami.edu,
% ]
% \address[1]{University of Miami, USA}
% \author[2]{Alexander Steen}[%
% orcid=0000-0001-8781-9462,
% email=alexander.steen@uni-greifswald.de,
% ]
% \address[2]{University of Greifswald, Germany}
% \author[3]{Pascal Fontaine}[%
% orcid=0000-0003-4700-6031,
% email=Pascal.Fontaine@uliege.be
% ]
% \address[3]{Université de Liège, Belgium}
% \begin{abstract}
% This paper describes the new TPTP format for representing interpretations.
% It provides a background survey that helped us ensure that the representation format is adequate
% for different types of interpretations: Tarskian, Herbrand, and Kripke interpretations.
% The needs of applications that use models are considered.
% The syntax and semantics of the new format is expounded in detail, with multiple examples.
% Verification of models is discussed.
% Some tools that support processing the new format are noted.
% The properties of interpretations represented in the new format are discussed.
% \end{abstract}
% \begin{keywords}
%   TPTP World \sep
%   Interpretations
% \end{keywords}

%----EasyChair style
\title{The New TPTP Format for Interpretations}

\author{
  Geoff Sutcliffe\inst{1}
\and
  Alexander Steen\inst{2}
\and
  Pascal Fontaine\inst{3}
}

\institute{
  University of Miami,
  Miami, USA\\
  \email{geoff@cs.miami.edu}
\and
  University of Greifswald,
  Greifswald, Germany\\
  \email{alexander.steen@uni-greifswald.de}
\and
  University of Li{\`e}ge,
  Li{\`e}ge, Belgium\\
  \email{Pascal.Fontaine@uliege.be}
}

\authorrunning{Sutcliffe, Steen, Fontaine}
\titlerunning{TPTP World Interpretations}

\begin{document}

\maketitle
%--------------------------------------------------------------------------------------------------
%----EasyChair style
\begin{abstract}
This paper describes the new TPTP format for representing interpretations.
It provides a background survey that helped us ensure that the representation format is adequate
for different types of interpretations: Tarskian, Herbrand, and Kripke interpretations.
The needs of applications that use models are considered.
The syntax and semantics of the new format is expounded in detail, with multiple examples.
Verification of models is discussed.
Some tools that support processing the new format are noted.
The properties of interpretations represented in the new format are discussed.
\end{abstract}
%--------------------------------------------------------------------------------------------------
\section{Introduction}
\label{Introduction}

Historically, Automated Theorem Proving (ATP) has, as the name suggests, focused largely on the
task of proving theorems from axioms -- the derivation of conclusions that follow inevitably 
from known facts~\cite{RV01-HAR}.
The axioms and the conjecture to be proved (and hence become a theorem) are written in an 
appropriately expressive logic, and the proofs are often similarly written in logic~\cite{SS+06}.
In the last two decades the converse task of disproving conjectures, proving that a conjecture is 
not a theorem of the axioms, has become increasingly important.
This process depends on finding a \emph{countermodel} for the conjecture, i.e., finding an 
\emph{interpretation} (a structure that assigns meaning to the symbols of the language of the
formulae, and consequently maps formulae to truth values) that is a \emph{model} of the axioms 
(maps the axioms to \textit{true}) but not a model for the conjecture (maps the conjecture to 
\textit{false}).
A salient application area that uses this form of ATP is verification~\cite{DKW08}, where a 
countermodel is used to pinpoint the reason why a proof obligation fails, and correspondingly 
points to the location of the fault in the system being verified.
Other applications of model finding include checking the consistency of an axiomatization 
\cite{SS+17}, operations research~\cite{Hoo93}, commonsense reasoning~\cite{KR94}, and solving 
model finding problems~\cite{Win82}.

The TPTP World~\cite{Sut17} (\href{https://www.tptp.org}{\tt www.tptp.org}) is a well established 
infrastructure that supports research, development, and deployment of 
% Automated Theorem Proving 
ATP systems.
Various parts of the TPTP World have been deployed in a range of applications, in both academia 
and industry.
The TPTP World includes the TPTP problem library~\cite{Sut09}, 
the TSTP solution library~\cite{Sut10}, 
tools and services for processing ATP problems and solutions~\cite{Sut10}, 
and it supports the CADE ATP System Competition (CASC)~\cite{Sut16}.
The TPTP language~\cite{Sut23-IGPL} is one of the keys to the success of the TPTP World.
Originally the TPTP language supported only first-order clause normal form (CNF)~\cite{SS98-JAR}.
Over the years full first-order form (FOF)~\cite{Sut09}, 
typed first-order form (TFF)~\cite{SS+12,BP13-TFF1}, 
typed extended first-order form (TXF)~\cite{SK18}, 
typed higher-order form (THF)~\cite{SB10,KSR16}, 
and non-classical forms (NXF, NHF)~\cite{SF+22}.
Most relevant to this work, the TPTP languages are used for writing ATP problems, derivations, 
and \emph{interpretations}~\cite{SS+06,Sut08-KEAPPA}.

A TPTP format for interpretations with finite domains has previously been defined~\cite{SS+06},
and has served the ATP community adequately for almost 20 years. 
The old format is output by several ATP systems, e.g., Paradox~\cite{CS03}, FM-Darwin~\cite{BF+06}, 
Vampire~\cite{KV13}.
Recently the need for a format for interpretations with infinite domains, and for a format for 
Kripke interpretations~\cite{Kri63}, has led to the development of the new TPTP format for 
interpretations.
This work describes the new format.
The underlying principle is unchanged: interpretations are represented in formulae written in
the TPTP language.

\paragraph{Related work:}
There are other concrete representations of interpretations in use:
The SMT-LIB standard~\cite{BFT17} defines a format for model output, and commands to inspect 
models.  
SAT solvers generally output models as specified by the SAT competitions~\cite{JL+12}, in a 
simple format similar to the DIMACS input format~\cite{Bab93}.
Some individual model finding systems have defined their own formats for models, e.g., the 
output formats of Nitpick~\cite{BN10-ITP} and Z3~\cite{dMB08}.
% +++
% Nikolaj says ...
% Z3 It produces models that define functions by expressions. For example a model of succ is 
% Succ(x) =X+ 1
% Works when domain is integer. Currently z3 does not implement infinite models for uninterpreted sorts. I would probably support infinite sorts by creating injection into an algebraic datatype and then support models that can be expressed over ADT.
% See also https://microsoft.github.io/z3guide/docs/logic/Quantifiers
% +++

\paragraph{This paper is organized as follows:}
Section~\ref{Interpretations} discusses the nature of interpretations, considering what is
needed from interpretations, and the various forms that interpretations can take.
Section~\ref{NewTarskian} defines the new format for Tarskian interpretations, and
Section~\ref{NewKripke} does the same for Kripke interpretations.
% Section~\ref{Verification} describes the semantic approach to model verification.
Section~\ref{Conclusion} concludes and discusses plans for future work.

%--------------------------------------------------------------------------------------------------
\section{About Interpretations}
\label{Interpretations}

%--------------------------------------------------------------------------------------------------
\subsection{What do we Need?}
\label{Need}

The needs of applications that use model finding vary according to their use of the model.
In the simplest case applications need to know only that a model exists.
Examples of such applications include checking the consistency of an axiomatization~\cite{CI15},
use as a subroutine in more complex reasoning, e.g., for
axiom selection~\cite{SP07,Pud07-ESARLT}, and establishing the existence of a bug in a
verification process\footnote{%
Bill McCune claimed that establishing the existence of a bug without having an explicit model
to help pinpoint the bug would be ``frustrating''. And he should have known.}.
A key weakness of a model finder system that claims to have found a model but does not output an 
explicit model is that it is necessary to trust the model finder.

In many applications it is necessary to have an explicit model, in some representation format that
allows for analysis of the model.
Applications that productively use an explicit model include finding inconsistencies in 
axiomatizations~\cite{SS+17}, identification of bugs in verification~\cite{CE82,QS82},
studying modal and description logics~\cite{SH13}, solving problems encoded as a model finding 
problems~\cite{Win82}, and evaluating formulae wrt the model~\cite{SS+23-LPAR}.
Manual inspection of explicit models can also be useful, e.g.,~\cite{EK+10}.
% Explicit models can be used for machine learning and improving model finders internally.
A key advantage of having an explicit model output is that the model can be verified, i.e., the
model finder does not need to be trusted,

Given the innate desirability of obtaining explicit models of satisfiable formulae, desirable
properties of interpretation representation can be considered.
\begin{packed_itemize}
\item Interpretations should be for the symbols of the input formulae.
\item Evaluation of any formulae wrt an interpretation should be possible, because many uses of
      interpretations can be reduced to evaluation~\cite[\S3.2]{CLP04}.
      The evaluation should be tractable, or in a tractabe core.
      This corresponds to the \emph{atom test} and \emph{formula evaluation} postulates suggested
      by~\cite{FL96,CLP04}.
\item Verification of models should be possible by checking that the problem formulae evaluate 
      to \textit{true} wrt the model.
      The verification should be tractable, or in a tractabe core.
\item Interpretations should be sufficiently (human) comprehensible to be useful in (human)
      applications.
\end{packed_itemize}

%--------------------------------------------------------------------------------------------------
\subsection{What do we Have?}
\label{Have}

A \emph{Tarskian interpretation}~\cite{TV56} consists of a non-empty domain of distinct elements 
(not the Herbrand Universe -- see Herbrand interpretation below) for each type used in the 
formulae (just one domain for untyped logic), mappings for function symbols from tuples of 
domain elements to the domain, and mappings for predicate symbols from tuples of domain elements 
to $\{true,false\}$~\cite{Hun96,Gal15}.
An overview of some ways of building and representing Tarskian interpretations is provided 
by~\cite{CLP04}, and~\cite{Pel03-EQMC} provides a comprehensive list of approaches.
A \emph{complete} interpretation can be used to evaluate all formulae that can be written in the 
language of the problem formulae, but a \emph{partial} interpretation can be used to evaluate the
problem formulae but not necessarily all possible formulae~\cite{BSW23}.
Two types of Tarskian interpretations are clear (and more might exist)~\ldots
\begin{packed_itemize}
\item \emph{Finite} Tarskian interpretations have only finite domains.
      The domain and symbol mappings can be be explicitly enumerated.
      Finite models are typically produced by starting with domains of size one, and incrementing 
      the sizes until a model is found.
      At each iteration the formulae are reduced to a decidable logic, e.g., 
      propositional~\cite{CS03,McC03-MACE4-TR} or function free~\cite{BF+09} logic, and an ATP 
      system for that logics is used to decide if there is a model.
      There are several ATP systems that produce finite Tarskian models, e.g., Paradox, FM-Darwin, 
      and Vampire.
\item \emph{Infinite} Tarskian interpretations have one or more infinite domains.
      Infinite domains can be explicitly generated, e.g., terms representing Peano numbers, or 
      implicitly specified, e.g., some set of algebraic numbers such as the integers~\cite{BB13}.
      % HOW IS THIS DONE?
      There are some ATP systems that produce infinite Tarskian models, e.g., 
      cvc5~\cite{BB+22-cvc5}, FEST~\cite{EPS24}, and Z3.
\end{packed_itemize}

A \emph{Herbrand interpretation}~\cite{Her30} has the Herbrand universe as the domain, the mapping 
for function symbols is the ``identity'', and the mapping for predicate symbols is from the 
Herbrand base to $\{true,false\}$.
Every set of formulae determines its set of Herbrand models.
Formulae in Skolem normal form determine Herbrand models with a Herbrand universe that includes any 
Skolem symbols. 
An empty set of formulae determines all interpretations, i.e., all interpretations are models
of the set.
Such sets of formulae can be the result of applying model preserving transformations to the 
problem formulae (even the input itself determines its set of Herbrand models), or be generated 
by an ATP system with the explicit intention of representing Herbrand models.
They are important in the context of resolution and all similar modern calculi; saturations (see 
below) are a common case.
\begin{packed_itemize}
\item Formulae that are intended to represent Herbrand interpretations are written 
      \emph{HI-formulae} in this paper, to avoid confusion.
      Examples include saturations (discussed separately in the next bullet point), a disjunction 
      of implicit generalisations (DIGs)~\cite{LM87}, sets of constrained unit 
      clauses~\cite{CZ92,CP95,CP95-TAB}, SGGS clause sequences~\cite{BP16}, tableaux~\cite{Hah01}
      % (as long as you use a proof confluent calculus, it is normally possible to construct 
      % a model from a saturated branch) 
      and hyper-tableaux~\cite{BFN96}, eq-interpretations~\cite{Pel03-EQMC}, and 
      predicate definitions over the term algebra~\cite{SK12}.
      E-KRHyper~\cite{PW07} was an ATP systems that produced hyper-tableaux, and
      iProver~\cite{Kor08,SK12} is an ATP system that outputs predicate definitions 
      over the term algebra.
\item \emph{Saturations}~\cite{BG+01,Pel03-JSC} are a special case of HI-formulae.
      A saturation is a fixed point for a set of clauses at which further application of a
      complete inference system does not generate any new clauses (up to redundancy).
      A saturation of a set of clauses determines the same set of Herbrand models as 
      the clauses themselves.
      Saturation-based ATP systems include E~\cite{SCV19}, Prover9~\cite{McC-Prover9-URL}, 
      Vampire, and Zipperposition~\cite{VB+21}.
\end{packed_itemize}
While the domain of a Herbrand interpretation determined by Herbrand formulae is known to be the 
Herbrand universe, there might not be an explicit symbol interpretation that can be used 
constructively by users.

A \emph{Kripke interpretation}~\cite{Kri63} adds a layer of \emph{possible worlds} over Tarskian 
interpretations.
There can be a finite or infinite number of worlds.
There is an \emph{accessibility relation} between the worlds, which can be subject to the
requirements of the logic being used, e.g., for modal logic \textbf{M} the accessibility 
relation must be reflexive~\cite{Gar18}.
Within each world there is a Tarskian interpretation, each possibly having different domains.
If \emph{local terms} are assumed, the designation of a ground term in a world may be chosen 
from only the domain in that world. 
If \emph{global terms} are assumed, the designation of a ground term in a world may be chosen 
from the domain in any world.
Quantification is over the domains in the world of evaluation (\emph{actualist quantification}), 
but the domains in the worlds can be chosen to coincide to simplify matters (\emph{possibilist 
quantification}).
Formulae can be evaluated wrt Kripke interpretations with finite worlds and local terms~\ldots
\begin{packed_itemize}
\item Evaluate modal operators using Kripke semantics.
\item Evaluate formulae within a world wrt the Tarskian interpretation in the world.
\end{packed_itemize}

The notions of interpretations, models, partial interpretations, finite interpretations,
Herbrand interpretations, etc., are captured in the SZS ontologies~\cite{Sut08-KEAPPA}, as
updated at 
\href{https://www.tptp.org/cgi-bin/SeeTPTP?Category=Documents\&File=SZSOntology}{\tt www.tptp.org}
\href{https://www.tptp.org/cgi-bin/SeeTPTP?Category=Documents\&File=SZSOntology}{\tt /cgi-bin/SeeTPTP?Category=Documents\&File=SZSOntology}.
For this work the ontology was extended with a new value \emph{Model Preserving} (MPR), defined
as ``Some interpretations are models of Ax, and
  some interpretations are models  of C, and
  all models of C are conservative extensions of models of Ax
  (which means that all models of C are models of Ax)''.
This is used for transformations on satisfiable sets of formulae in which the models of the set 
are unchanged, or are changed only by adding new domain elements or mappings, so that the
extended models are still models of the original formulae. 
Examples of such transformations are Skolemization, and adding logical consequences of a set 
into the set.

%--------------------------------------------------------------------------------------------------
\subsection{Do we Have what we Need?}
\label{HaveNeed}

The new TPTP format represents interpretations in \emph{interpretation-formulae} -- the details 
are provided in Sections~\ref{NewTarskian}, \ref{NewHerbrand} and~\ref{NewKripke}.
Interpretation-formulae are written in an extension of the language of the formulae being 
interpreted, extending the vocabulary but still using TPTP syntax.

Figure~\ref{ModelLandscape} provides an overview of the situation.
The starting point is the set of {\sf Satisfiable formulae} written in the language $\Sigma$. 
The satisfiable formulae might have been formed from 
{\sf Ax $\cup$ \{{\raisebox{0.4ex}{\texttildelow}}C\}}. 
Going down leads to the {\sf Models} of the satisfiable formulae.
Going left from the {\sf Satisfiable formulae in $\Sigma$} is the pathway taken by ATP systems 
that find a Tarskian/Kripke model, and output interpretation-formulae representing the model.
The interpretation-formulae can be for a conservative extension of the language of the input
formula, e.g., by the addition of Skolem symbols, defined symbols, etc. (hence $\Sigma^+$).
If the interpretation-formulae correctly represent a model of the satisfiable formulae, then
the satisfiable formulae can be proved ($\vDash$) from the interpretation-formulae.
The models of the interpretation-formulae are conservative extensions of a subset of the models 
of the satisfiable formulae.
Going right from the {\sf Satisfiable formulae in $\Sigma$} is the pathway taken by ATP systems
(for classical logics at least) that apply model preserving transformations ({\sf MPR}s) to the 
satisfiable set, to produce formulae that determine Herbrand models of the satisfiable formulae.
The satisfiable formulae can be proved from the sets that result from applying MPRs

\begin{figure}[htbp]
\centering
\includegraphics[width=0.75\textwidth]{ModelLandscape.pdf}
\caption{A Landscape of Model Building}
\label{ModelLandscape}
\end{figure}

To evaluate a formula wrt interpretation-formulae~\ldots
% $\varphi$ wrt a given interpretation $I$ ($I\,\vdash\,\Phi$ means that 
% $\Phi$ is \textit{true} in $I$, i.e., $I$ is a model of formula $\Phi$)~\ldots
\begin{packed_itemize}
\item For Tarskian interpretation-formulae with finite domains, direct evaluation can be used.
      \begin{packed_itemize}
      \item Interpret quantifiers using Tarskian semantics.
      \item Interpret ground (grounded with domain elements) terms and atoms using the mappings.
      \item Interpret boolean formulae using the truth tables for connectives.
      \end{packed_itemize}
      This approach is taken internally in Vampire.
\item For Tarskian interpretation-formulae, theorem proving can be used.
      \begin{packed_itemize}
      \item If a formula can be proved from the interpretation-formulae then it is \textit{true} 
            in the interpretation represented by the interpretation-formulae.
      \item If a formula can be disproved from the interpretation-formulae then it is 
            \textit{false} in the interpretation represented by the interpretation-formulae.
      \item In practice, a formula might be neither proved nor disproved within reasonable 
            resource limits, so that nothing is known.
      \end{packed_itemize}
\item For Herbrand interpretations determined by HI-formulae, theorem proving can be used~\ldots
      \begin{packed_itemize}
      \item If a formula can be proved from the HI-formulae then it is \textit{true} in all 
            the Herbrand interpretations determined by the HI-formulae.
      \item If a formula can be disproved from the HI-formulae then it is \textit{false} in 
            all the Herbrand interpretations determined by the HI-formulae.
      \item In practice, a formula might be neither proved nor disproved within reasonable 
            resource limits, so that nothing is known.
      \end{packed_itemize}
      \emph{I believe that this verification technique works, and so do Stephan Schulz and 
      Uwe Waldmann, but Andrei Voronkov and Christoph Weidenbach say they do not.
      I'm looking for help on this.}
\item For Kripke interpretation-formulae, theorem proving can be used.
      This is described in Section~\ref{KripkeVerification}.
\end{packed_itemize}

%--------------------------------------------------------------------------------------------------
\subsection{Model Verification}
\label{Verification}

Given ways to evaluate a formula wrt interpretation-formulae, models represented in
interpretation-formulae can be checked.
This has (at least) the following aspects: 
\begin{packed_enumerate}
\item Validate that the interpretation-formulae correctly represent the model found 
      by the ATP system.
\item Verify that the type declarations and interpretation-formulae are syntactically well-formed 
      and well-typed. 
\item Verify that the interpretation-formulae are satisfiable.
\item Verify that the interpretation represented by the interpretation-formulae is a model for 
      the given formulae.
\end{packed_enumerate}

These steps can be (in)completed as follows~\ldots
\begin{enumerate}
\item This cannot be confirmed without insight into the ATP system that found the model.
\item This can be confirmed using standard parsing and type checking tools, 
      e.g.,~\cite{VS06,HR15,Ste23}.
\item This can be confirmed using a trusted model finder.
      Hopefully, confirming that the interpretation-formulae are satisfiable is much easier than 
      finding the model itself, so the ATP system used to check the satisfiability can be weaker 
      and more trusted than the ATP system that found the model.
      In light of the next point, the model finding task can be made easier by combining the
      interpretation-formulae with the problem formulae (axioms and negated conjecture).
\item This can be confirmed using the theorem proving approach to verification, in which the 
      problem formulae $\Phi$ are proved from the interpretation-formulae $\varphi$ using a trusted 
      theorem prover.
      The soundness of this approach is proved by showing that if $\Phi$ can be proved from 
      $\varphi$ then the interpretation $I$ represented by $\varphi$ is a model of $\Phi$.
      This is done for finite Tarskian interpretations for untyped first-order logic 
      in~\cite{SS+23-LPAR}.
%      by proving that if a formulae $\Phi$ can be 
%      proved from the interpretation-formulae $\varphi$ then the interpretation $I$ 
%      represented by $\varphi$ is a model of $\Phi$.
      We believe the proof in~\cite{SS+23-LPAR} lifts naturally to TFF and THF, but is technically 
      more complicated due to the introduction of types.
      % and type-promotion functions.
      The extension to infinite domains is quite simple after that.
      For Kripke interpretation-formulae it is necessary to make changes that reduce the
      verification problem to TXF/THF (see Section~\ref{KripkeVerification}).
\end{enumerate}

Steps~2 to 4 are implemented in the AGMV model verifier~\cite{SS+23-LPAR}, available in the
SystemOnTSTP~\cite{Sut07-CSR} web interface
\href{https://www.tptp.org/cgi-bin/SystemOnTSTP}{{\tt www.tptp.org/cgi-bin/SystemOnTSTP}}.
      
%--------------------------------------------------------------------------------------------------
\section{The New Format for Tarskian Interpretations}
\label{NewTarskian}

A simple Tarskian interpretation-formula is a conjunction of components (see simple FOF and TFF
examples in Appendices~\ref{FOF_Finite.s}, \ref{TFF_Finite_SeparateDomains.s}, 
and~\ref{TFF_Finite.s})~\ldots
\begin{packed_itemize}
\item A domain for each of the types in the problem formulae.
\item Interpretation of non-boolean symbols, as equalities whose left-hand sides are formed from 
      symbols applied to domain elements, and whose right-hand sides are domain elements.
\item Interpretation of boolean symbols, as literals formed from symbols applied to domain 
      elements; positive literals are \emph{true} and negative literals are \emph{false}.
\end{packed_itemize}

Note that function and predicate symbols are interpreted by applying them directly to domain
elements (\emph{{\`a} la}~\cite[\S5.3.4]{Gal15}), rather than using the presentation of 
interpretations that introduces a new interpretation function for each function/predicate symbol 
\cite[\S5.3.2]{Gal15}.
This approach obviates the need for introducing interpretation functions, and makes 
interpretation of formulae using theorem proving simpler.
However, applying the problem's function and predicate symbols to domain elements that are 
defined with different types to the problem's types requires using \emph{type-promotion} 
bijections to keep interpretation-formulae well-typed (see Section~\ref{TarskianNewFiniteTypes}).
% The explanations and examples that follow will convince you of that!

Examples of single Tarskian interpretation-formulae are in Appendices~\ref{FOF_Finite.s}, 
\ref{TFF_Finite.s}, \ref{TFF_Peano.s}, \ref{TFF_Integer.s}, and~\ref{THF_Finite.s}, illustrating 
the components described below. 
Tarskian interpretations split over multiple interpretation-formulae, as in 
Appendices~\ref{FOF_Finite_Medium.s}, \ref{FOF_Finite_Fine.s}, \ref{TFF_Finite_Medium.s}, 
\ref{TFF_Finite_Fine.s}, and~\ref{THF_Finite_Medium.s}, are explained in 
Section~\ref{NewTarskianSplit}.
Tarskian interpretations that are compacted using quantification, as in \ref{TFF_Finite_Compact.s}
and~\ref{THF_Finite_Compact.s}, are explained in Section~\ref{NewTarskianCompact}.
Examples of interpretation-formulae that determine Herbrand interpretations, as in 
Appendices~\ref{FOF_Formulae.s} and~\ref{FOF_Saturation.s}, are explained in 
Section~\ref{NewHerbrand}.

%--------------------------------------------------------------------------------------------------
\subsection{FOF Tarskian Interpretations}
\label{FOFTarskian}

Appendix~\ref{FOF_Finite.p} shows a FOF problem that has a countermodel with a finite domain, 
which is shown in Appendix~\ref{FOF_Finite.s}.

The domain specification is a conjunction of~\ldots
\begin{packed_itemize}
\item Specification of the domain elements as a universally quantified disjunction of equalities 
      whose right-hand sides are the domain elements, 
      e.g., in Appendix~\ref{FOF_Finite.s}~\ldots\\
      \hspace*{0.5cm}\smalltt{! [X] : ( X = "a" | X = "f" | X = "john" | X = "gotA")}
\item Specification of the distinctness of the domain elements.
      Distinctness can be specified with pairwise inequalities, with the {\tt \$distinct} 
      predicate, or by using {\tt "double quoted"} terms as domain elements (different 
      {\tt "double quoted"} terms are known to be unequal (and often not used in problems, which 
      makes them easy to identify as domain elements)),
      e.g., in Appendix~\ref{FOF_Finite.s} the domain elements are {\tt "double quoted"}.
\end{packed_itemize}

The function mappings are equalities between domain elements and functions applied to domain 
elements,
e.g., in Appendix~\ref{FOF_Finite.s}~\ldots \\
\hspace*{0.5cm}\smalltt{grade\_of("john") = "f"}\\
The predicate mappings are atoms, 
e.g., in Appendix~\ref{FOF_Finite.s}~\ldots \\
\hspace*{0.5cm}\smalltt{created\_equal("john","gotA")}\\
Note that for a complete interpretation all function and predicate mappings need to be provided,
even if they make no sense in a typed sense, e.g., in Appendix~\ref{FOF_Finite.s}~\ldots \\
\hspace*{0.5cm}\smalltt{grade\_of("f") = "a"}\\
\hspace*{0.5cm}\smalltt{{\raisebox{0.4ex}{\texttildelow}} created\_equal("a","john")}

Appendix~\ref{FOF_Finite.s.p} shows the verification problem for the model.

%--------------------------------------------------------------------------------------------------
\subsection{Tarskian Interpretations, Reusing Problem Types}
\label{TarskianReusingTypes}

Appendix~\ref{TFF_Finite.p} shows a TFF problem that has a countermodel with finite domains,
which is shown in Appendix~\ref{TFF_Finite.s}.
Appendix~\ref{THF_Finite.p} shows a THF problem that has a countermodel with finite domains,
which is shown in Appendix~\ref{THF_Finite.s}.

Each domain specification is a conjunction of~\ldots
\begin{packed_itemize}
\item Specification of the domain elements as a universally quantified disjunction of equalities 
      whose right-hand sides are the domain elements, 
      e.g., in Appendix~\ref{TFF_Finite.s}~\ldots\\
      \hspace*{0.5cm}\smalltt{! [DC: cat]: ( DC = d\_garfield | DC = d\_arlene | DC = d\_nermal )}\\
      and in Appendix~\ref{THF_Finite.s}~\ldots\\
      \hspace*{0.5cm}\smalltt{( ! [DB: beverage] : ( DB = d\_coffee )}\\
      \hspace*{0.5cm}\smalltt{\& ! [DS: syrup] : ( DS = d\_date ) )}\\
\item Specification of the distinctness of the domain elements, unless implicit from their type.
      e.g., in Appendix~\ref{TFF_Finite.s}~\ldots\\
      \hspace*{0.5cm}\smalltt{\$distinct(d\_garfield,d\_arlene,d\_nermal)}
\end{packed_itemize}

The function mappings are equalities between domain elements and functions applied to domain 
elements, 
e.g., in Appendix~\ref{TFF_Finite.s}~\ldots \\
\hspace*{0.5cm}\smalltt{loves(d\_garfield) = d\_garfield}\\
and in Appendix~\ref{THF_Finite.s}~\ldots \\
\hspace*{0.5cm}\smalltt{( mix @ d\_coffee @ d\_date ) = d\_coffee )}\\
The predicate mappings are atoms, 
e.g., in Appendix~\ref{TFF_Finite.s}~\ldots \\
\hspace*{0.5cm}\smalltt{{\raisebox{0.4ex}{\texttildelow}}\,owns(d\_jon,d\_nermal)}\\
and in Appendix~\ref{THF_Finite.s}~\ldots \\
\hspace*{0.5cm}\smalltt{( hot @ d\_coffee )}

The TFF and THF interpretation-formulae are preceded by the necessary type declarations~\ldots
\begin{packed_itemize}
\item The types in the problem.
\item The types of the domains.
\item The types of the domain elements.
\end{packed_itemize}

Appendices~\ref{TFF_Finite.s.p} and~\ref{THF_Finite.s.p} show the verification problems for the 
models.

%--------------------------------------------------------------------------------------------------
\subsection{Tarskian Interpretations, New Finite Domain Types}
\label{TarskianNewFiniteTypes}

Reusing the problem types for domain elements can get murky, e.g., when quantification over only 
the domain elements is intended. 
It can be cleaner to use new types for domain elements, and it becomes necessary when the domain 
elements are complex or of a defined type such as {\tt \$int} (see Section~\ref{TarskianInfinite}).
As noted in the introduction to Section~\ref{NewTarskian}, applying the problem's function and 
predicate symbols to domain elements that are defined with different types to the problem's types 
requires using type-promotion bijections to ``convert'' domain elements to terms of the 
corresponding problem type.

Appendix~\ref{TFF_Finite.p} shows a TFF problem that has a countermodel with finite domains,
which is shown in Appendix~\ref{TFF_Finite_SeparateDomains.s}.

Each domain specification is a conjunction of~\ldots
\begin{packed_itemize}
\item Spcification of the domain for each problem type, as a formula that makes the 
      type-promotion function a surjection, 
      e.g., in Appendix~\ref{TFF_Finite_SeparateDomains.s}~\ldots\\
      \hspace*{0.5cm}\smalltt{! [C: cat] : ? [DC: d\_cat] : C = d2cat(DC)}
\item Specification of the domain elements as a universally quantified disjunction of equalities 
      whose right-hand sides are the domain elements, 
      e.g., in Appendix~\ref{TFF_Finite_SeparateDomains.s}~\ldots\\
      \hspace*{0.5cm}\smalltt{! [DC: d\_cat]: ( DC = d\_garfield | DC = d\_arlene | DC = d\_nermal )}
\item Specification of the distinctness of the domain elements, unless implicit from their type.
      e.g., in Appendix~\ref{TFF_Finite.s}~\ldots\\
      \hspace*{0.5cm}\smalltt{\$distinct(d\_garfield,d\_arlene,d\_nermal)}
\item A formula making the type-promotion function an injection, which together with the 
      surjectivity makes it a bijection, 
      e.g., in Appendix~\ref{TFF_Finite_SeparateDomains.s}~\ldots\\
      \hspace*{0.5cm}\smalltt{! [DC1: d\_cat,DC2: d\_cat] : ( d2cat(DC1) = d2cat(DC2) => DC1 = DC2 )}
\end{packed_itemize}

The function mappings are equalities between type-promoted domain elements and functions applied 
to type-promoted domain elements, 
e.g., in Appendix~\ref{TFF_Finite_SeparateDomains.s}~\ldots \\
\hspace*{0.5cm}\smalltt{loves(d2cat(d\_garfield)) = d2cat(d\_garfield)}\\
The predicate mappings are atoms, 
e.g., in Appendix~\ref{TFF_Finite_SeparateDomains.s}~\ldots \\
\hspace*{0.5cm}\smalltt{{\raisebox{0.4ex}{\texttildelow}}\,owns(d2human(d\_jon),d2cat(d\_nermal))}

The TFF and THF interpretation-formulae are preceded by the necessary type declarations~\ldots
\begin{packed_itemize}
\item The types in the problem.
\item The types of the domains.
\item The types of the domain elements.
\item The types of the type-promotion functions.
\end{packed_itemize}

Appendix~\ref{TFF_Finite_SeparateDomains.s.p} shows the verification problems for the model.

%--------------------------------------------------------------------------------------------------
\subsection{Tarskian Interpretations, Infinite Domains}
\label{TarskianInfinite}

Interpretations can have infinite domains formed from terms or defined types such as {\tt \$int}.
Appendix~\ref{TFF_Infinite.p} shows a TFF problem that has a model with an infinite domain.
Appendix~\ref{TFF_Peano.s} shows the model with an infinite term domain, and
Appendix~\ref{TFF_Integer.s} shows the model with a {\tt \$int} domain.

      Note that $\bullet$~the defined type {\smalltt{\$int}} is the domain type for the formula 
      type {\smalltt{person}}, so that there is no specification of the domain elements and their 
      distinctness; $\bullet$~universal quantification is used for the interpretation of function 
      and predicate symbols to cover an infinite number of argument tuples; $\bullet$~the 
      interpretation of function and predicate symbols is not given for argument tuples with 
      negative integers, i.e., this is an example of a partial interpretation.

Each domain specification is a conjunction of~\ldots
\begin{packed_itemize}
\item The domain for each problem type, as a formula that makes the type-promotion function a 
      surjection, 
      e.g., in Appendix~\ref{TFF_Peano.s}~\ldots\\
      \hspace*{0.5cm}\smalltt{! [P: person] : ? [I: peano] : ( P = peano2person(I) )}\\
      and in Appendix~\ref{TFF_Integer.s}~\ldots\\
      \hspace*{0.5cm}\smalltt{! [P: person] : ? [I: \$int] : P = int2person(I)}\\
      If the problem type and the domain type are the same defined type, e.g., both are 
      {\tt \$int}) this is unecessary.
\item Specification of the domain elements as an existentially quantified formula that captures an
      infinite disjunction of equalities,
      e.g., in Appendix~\ref{TFF_Peano.s}~\ldots\\
      \hspace*{0.5cm}\smalltt{! [I: peano] : ( I = zero | ? [P: peano] : I = s(P) )} \\
      If the domain is a defined type such as {\tt \$int} this is unecessary,
      e.g., in Appendix~\ref{TFF_Integer.s}.
\item Specification of the distinctness of the domain elements, unless implicit from their type.
      e.g., in Appendix~\ref{TFF_Peano.s}~\ldots\\
      \hspace*{0.5cm}\smalltt{( peano\_less(I1,I2) => I1 != I2 )}
      If the domain is a defined type such as {\tt \$int} this is unecessary,
      e.g., in Appendix~\ref{TFF_Integer.s}.
\item A formula making the type-promotion function an injection, which together with the 
      surjectivity makes it a bijection, 
      e.g., in Appendix~\ref{TFF_Peano.s}~\ldots\\
      \hspace*{0.5cm}\smalltt{! [I1: peano,I2: peano] : ( peano2person(I1) = peano2person(I2) => I1 = I2 )}\\
      and in Appendix~\ref{TFF_Integer.s}~\ldots\\
      \hspace*{0.5cm}\smalltt{! [I1: \$int,I2: \$int] : ( int2person(I1) = int2person(I2) => I1 = I2 ) )}
\end{packed_itemize}

The function mappings are universally quantified equalities between type-promoted domain 
elements and functions applied to type-promoted domain elements, 
e.g., in Appendix~\ref{TFF_Peano.s}~\ldots \\
\hspace*{0.5cm}\smalltt{! [I: peano] : child\_of(peano2person(I)) = peano2person(s(I))}\\
and in Appendix~\ref{TFF_Integer.s}~\ldots\\
\hspace*{0.5cm}\smalltt{! [I: \$int] : child\_of(int2person(I)) = int2person(\$sum(I,1))}\\
The predicate mappings are universally quantified formulae, 
e.g., in Appendix~\ref{TFF_Peano.s}~\ldots \\
\hspace*{0.5cm}\smalltt{! [A: peano,D: peano] :}\\
\hspace*{1.0cm}\smalltt{( is\_descendant(peano2person(A),peano2person(D)) <=> peano\_less(A,D) )}\\
and in Appendix~\ref{TFF_Integer.s}~\ldots\\
\hspace*{0.5cm}\smalltt{! [A: \$int,D: \$int] :}\\
\hspace*{1.0cm}\smalltt{( is\_descendant(int2person(A),int2person(D)) <=> \$less(A,D) )}\\
\hspace*{0.75cm}\smalltt{<=> peano\_less(A,D) )}\\

The TFF and THF interpretation-formulae are preceded by the necessary type declarations~\ldots
\begin{packed_itemize}
\item The types in the problem.
\item The types of the domains.
\item The types of the domain elements.
\item The types of the type-promotion functions.
\end{packed_itemize}

Appendices~\ref{TFF_Peano.s.p} and~\ref{TFF_Integer.s.p} show the verification problems for the 
models.

%--------------------------------------------------------------------------------------------------
\subsection{Tarskian Interpretations Split over Multiple Formulae}
\label{NewTarskianSplit}

The interpretation-formulae described thus far put all the information about an interpretation 
in a single interpretation-formula.
In some situations it is useful to separate the various components, e.g., the domains could be
separated from the symbol mappings.
The new TPTP format offers splitting in a flexible way, at medium and fine grained levels, using 
annotated formula subroles.

At the medium grained level, the {\tt interpretation} role can be extended with the subroles
{\tt domain} and {\tt mapping}.
Two (or more) interpretation-formulae are used, each containing the corresponding parts of the 
interpretation.
Appendices~\ref{FOF_Finite_Medium.s} and~\ref{TFF_Finite_Medium.s} show examples of
splitting the interpretation-formulae in Appendices~\ref{FOF_Finite.s} and~\ref{TFF_Finite.s} 
respectively, which separate the domain specifications from the symbol mappings, e.g., in 
Appendix~\ref{TFF_Finite.s} the annotated formula~\ldots \\
\hspace*{1.0em}\smalltt{tff(garfield\_domains,interpretation-domain,} \\
contains the information about the two domains, and the annotated formula~\ldots \\
\hspace*{1.0em}\smalltt{tff(garfield\_mappings,interpretation-mapping,} \\
contains the symbol mappings.
Note that each role and role-subrole pair can be used multiple times according to need, e.g.,
in Appendix~\ref{FOF_Finite_Medium.s} there are two {\tt interpretation-mapping} annotated
formulae, one for functions and one for predicates.

At the fine grained level, interpretation-formulae can split the individual domains and symbol 
mappings, with the {\tt domain} and {\tt mapping} subroles given arguments to indicate
which domain or symbol mapping is recorded.
For {\tt domain}s the arguments of the subrole are the domain in the problem and the domain in the 
interpretation.
For {\tt mapping}s the arguments are the symbol and its result domain type.
Appendices~\ref{FOF_Finite_Fine.s} and \ref{TFF_Finite_Fine.s} show examples of splitting the 
interpretation-formulae in Appendices~\ref{FOF_Finite.s} and~\ref{TFF_Finite.s} respectively, 
e.g., in Appendix~\ref{TFF_Finite.s} the annotated formula~\ldots \\
\hspace*{1.0em}\smalltt{tff(garfield\_domain\_human,interpretation-domain(human,d\_human),} \\
contains the {\tt d\_human} domain specification, and~\ldots \\
\hspace*{1.0em}\smalltt{tff(garfield\_domain\_cat,interpretation-domain(cat,d\_cat),} \\
contains the {\tt d\_cat} domain specification.

The medium and fine grained splitting can be mixed.
Appendix~\ref{THF_Finite_Medium.s} shows an example of mixed splitting of 
Appendix~\ref{THF_Finite.s}, where the domains are specified separately in the annotated
formulae~\ldots \\
\hspace*{1.0em}\smalltt{thf(hot\_coffee\_beverage,interpretation-domain(beverage,d\_beverage),} \\
and~\ldots \\
\hspace*{1.0em}\smalltt{thf(hot\_coffee\_syrup,interpretation-domain(syrup,d\_syrup),} \\
while all the symbol mappings are in~\ldots \\
\hspace*{1.0em}\smalltt{thf(hot\_coffee,interpretation-mapping,}

%--------------------------------------------------------------------------------------------------
\subsection{Tarskian Interpretations Compacted using Quantification}
\label{NewTarskianCompact}

The full logical language can be used in interpretation-formulae to provide compaction.
Appendices~\ref{TFF_Finite_Compact.s} and~\ref{THF_Finite_Compact.s} show examples compacting the
interpretation-formulae in Appendices~\ref{FOF_Finite.s} and~\ref{TFF_Finite.s} respectively.
In Appendix~\ref{TFF_Finite_Compact.s} note how universal quantification is used to map
{\tt loves} to {\tt d\_garfield} for all {\tt d\_cats}~\ldots \\
\hspace*{0.5cm}\smalltt{!\,[DC:\,d\_cat]\,:\,(\,loves(d2cat(DC))\,=\,d2cat(d\_garfield)\,)} \\
and in Appendix~\ref{THF_Finite_Compact.s} universal quantification is used to say that for all
functions of type {\tt beverage > syrup} and all {\tt syrups}, applying the function to
{\tt d\_coffee} and the syrup results in {\tt d\_coffee}~\ldots \\
\hspace*{0.5cm}\smalltt{!\,[F:\,beverage\,>\,syrup\,>\,beverage,S:\,syrup]\,:} \\
\hspace*{0.8cm}\smalltt{(\,(\,F\,@\,(\,d2beverage\,@\,d\_coffee\,)\,@\,(\,d2syrup\,@\,S\,)\,)} \\
\hspace*{0.8cm}\smalltt{=\,(\,d2beverage\,@\,d\_coffee\,)\,)}

%--------------------------------------------------------------------------------------------------
\section{HI-formulae and Saturations}
\label{NewHerbrand}

HI-formulae determine sets of Herbrand interpretations.
Interpretation-formulae can be used for these, although the actual Herbrand interpretations are
not easy to extract.
To indicate that the interpretation-formulae are intended to determine Herbrand interpretations 
they are given the subrole {\tt herbrand}.
The problem in Appendix~\ref{FOF_Finite.p} has a HI-formulae model formed from predicate 
definitions over the term algebra, which is shown in Appendix~\ref{FOF_Formulae.s}.
The problem in Appendix~\ref{FOF_Finite.p} also has a saturation, which is shown in
Appendix~\ref{FOF_Saturation.s}.
Appendices~\ref{FOF_Formulae.s.p} and~\ref{FOF_Saturation.s.p} show the corresponding verification 
problems.

%--------------------------------------------------------------------------------------------------
\section{Kripke Interpretations}
\label{NewKripke}
 
The new TPTP format for Kripke interpretations also uses interpretation-formulae.
As was noted in Section~\ref{Have}, Kripke interpretations can have either a finite or an
infinite number of worlds, and the interpretations in a world can be Tarskian or Herbrand.
\emph{I don't really have a firm handle on the cases with an infinite number of worlds, but I 
have some tentative examples that show they can be represented in the new format.\footnote{%
\href{https://www.tptp.org/TPTP/Proposals/InterpretationsModels.shtml\#KripkeInfiniteFinite}{{\tt www.tptp.org/TPTP/Proposals/InterpretationsModels.shtml}}}
For now the format is explained with examples that have a finite number of worlds and finite
Tarskian interpretations in the worlds.}
For interpretations of classical logic formulae the semantics is the standard classical semantics 
of TXF.
In contrast, for Kripke interpretations the semantics is that of modal logic enriched with four 
new hybrid defined symbols:
\begin{packed_itemize}
\item A defined type {\tt \$world} is used for the worlds of the interpretation.
      Different constants of type {\tt \$world} are known to be unequal (but as yet no ATP 
      systems implement that, so it's necessary to encode that explicitly using inequalities or 
      the {\tt \$distinct} predicate).
\item A defined predicate {\tt \$accessible\_world} of type {\tt (\$world\,*\,\$world)\,>\,\$o}
      is used to specify the accessibility relation between worlds.
\item A defined constant {\tt \$local\_world} of type {\tt \$world\,>\,\$o} is used to specify 
      the world in which a local (the default) conjecture is to be proved. 
\item A defined predicate {\tt \$in\_world} of type {\tt (\$world\,*\,\$o)\,>\,\$o} is used to 
      specify the interpretations in the worlds.
\end{packed_itemize}

A single Kripke interpretation-formula is a conjunction of~\ldots
\begin{packed_itemize}
\item A specification of the worlds.
\item Explication of the distinctness of the worlds (by definition different world are known to
      be distinct, but no ATP systems know that yet).
\item The accessibility relation.
\item Specification of the local world if any.
\item For each world, its Tarskian interpretation (also in the new TPTP format for interpretations),
      augmented by existential subfomulae that require the existence of the world's domain 
      elements -- these are necessary because the semantics is that of modal logic (see
      Sections~\ref{NewKripkeFiniteFinite} and~\ref{NewKripkeSplitCompact} for examples).
\end{packed_itemize}
The interpretation-formulae are preceded by the necessary type declarations:
\begin{packed_itemize}
\item The types for the interpretations in the worlds.
\item The worlds declared of type {\tt \$world}, e.g., {\tt w1: \$world}.
\end{packed_itemize}

The {\tt logic} specification of the problem is included to specify that the interpretation is
for formulae in that logic.
This information is needed when processing an interpretation, e.g., in verification (see 
Section~\ref{Verification}). 
The interpretation-formula does not provide this information because it underspecifies the 
logic in use, e.g., it's usually not possible to see whether the interpretation exemplifies modal 
system K or modal system S5 -- in both cases the interpretation could interpret the accessibility 
relation as an equivalence relation (this is required for S5 but it is also OK for K).

%--------------------------------------------------------------------------------------------------
\subsection{Finite-Finite Kripke Interpretations}
\label{NewKripkeFiniteFinite}

Appendix~\ref{NXF_Finite-Finite-Global.p} shows a NXF problem that has a countermodel with
finite worlds each of which contains a finite Tarskian interpretation, which is shown in
Appendix~\ref{NXF_Finite-Finite-Global.s}.
The problem has global axioms and a local conjecture.
The countermodel was found by embedding the problem into THF using the NTFLET 
tool~\cite{Ste22,Ste23}, running Nitpick on the THF problem, and converting Nitpick's output
to the TPTP format by hand.
There are two worlds~\ldots \\
\hspace*{0.5cm}\smalltt{!\,[W:\,\$world]\,:\,(\,W\,=\,w1\,|\,W\,=\,w2\,)} \\
\hspace*{0.5cm}\smalltt{\$distinct(w1,w2)} \\
with a complete accessibility relation (meeting the requirements of modal logic 
\textbf{M})~\ldots \\
\hspace*{0.5cm}\smalltt{\$accessible\_world(w1,w1)} \\
\hspace*{0.5cm}\smalltt{\$accessible\_world(w2,w2)} \\
\hspace*{0.5cm}\smalltt{\$accessible\_world(w1,w2)} \\
\hspace*{0.5cm}\smalltt{\$accessible\_world(w2,w1)} \\
The conjecture is disproved in a local world~\ldots \\
\hspace*{0.5cm}\smalltt{\$local\_world = w2} \\
The finite Tarskian interpretations for the worlds are provided in the format described in 
Section~\ref{NewTarskian}~\ldots \\
\hspace*{0.5cm}\smalltt{\$in\_world(w1,}\emph{the Tarskian interpretation}{\tt )} \\
\hspace*{0.5cm}\smalltt{\$in\_world(w2,}\emph{the Tarskian interpretation}{\tt )} \\
Note the augmentation of the Tarskian interpretations with subformulae such as 
{\tt ?\,[DP:\,d\_person]\,:\,(\,DP\,=\,d\_alex\,)}.
The quantification semantics is not classical, but instead that of modal logic, i.e., the 
quantification is over the domain elements that exist in {\tt w1}, i.e., that subformulae requires 
that the domain element {\tt d\_lex} exists in {\tt w1}.
Appendix~\ref{NXF_Finite-Finite-Global.s.p} shows the verification problem for the model.

Appendix~\ref{NXF_Finite-Finite-Local.p} shows a NXF problem that has a countermodel with
finite worlds, each of which contains a finite Tarskian interpretation, which is shown in
Appendix~\ref{NXF_Finite-Finite-Local.s}.
The problem has both local and global axioms, and a local conjecture.
This example illustrates how a local axiom (with role {\tt axiom-local}) is satisfied in only the 
local world ({\tt w1}).
Appendix~\ref{NXF_Finite-Finite-Local.s.p} shows the verification problem for the model.

%--------------------------------------------------------------------------------------------------
\subsection{Kripke Interpretations Split and Compacted}
\label{NewKripkeSplitCompact}

Kripke interpretation-formulae can be split to separate the various components of the 
interpretation.
The {\tt interpretation} role can be extended with the subroles {\tt world} and {\tt in\_world}.
Appendix~\ref{NXF_Finite-Finite-Global_Medium.s} shows a medium grained split of 
Appendix~\ref{NXF_Finite-Finite-Global.s}.
An annotated formula with the role {\tt interpretation-world} contains information about the
worlds of the interpretation, e.g., in Appendix~\ref{NXF_Finite-Finite-Global_Medium.s} the
annotated formula~\ldots \\
\hspace*{0.5cm}\smalltt{tff(leo\_workers\_worlds,interpretation-world,} \\
contains the information about the two worlds.
Annotated formulae with the role {\tt interpretation\-in\_world} provide information about the
interpretation in the world named as the first argument of the {\tt in\_world} subrole.
The second argument of the {\tt in\_world} subrole tells what information is provided, using the
roles and subroles for Tarskian/Herbrand interpretation-formulae, e.g., in 
Appendix~\ref{NXF_Finite-Finite-Global_Medium.s} the annotated formula~\ldots \\
\hspace*{0.5cm}\smalltt{tff(leo\_workers\_w1\_domain,interpretation-in\_world(w1,interpretation-domain),} \\
contains the information about the domains in world {\tt w1}, and the annotated formula~\ldots \\
\hspace*{0.5cm}\smalltt{tff(leo\_workers\_w1\_mappings,interpretation-in\_world(w1,interpretation-mapping),} \\
contains the information about the mappings in world {\tt w1}.

Splitting can be done in a flexible way, using the fine-grained splitting available for
Tarskian interpretation-formulae.
Appendix~\ref{NXF_Finite-Finite-Global_Fine.s} shows a more fine grained split of 
Appendix~\ref{NXF_Finite-Finite-Global.s}, in which the annotated formula~\ldots \\
\hspace*{0.5cm}\smalltt{tff(leo\_workers\_w1\_person,} \\
\hspace*{0.8cm}\smalltt{interpretation-in\_world(w1,interpretation-domain(person,d\_person)),} \\
contains the information about the domain {\tt d\_person} in world {\tt w1}, and the annotated 
formula~\ldots \\
\hspace*{0.5cm}\smalltt{tff(leo\_workers\_w2\_gets\_rich,} \\
\hspace*{0.8cm}\smalltt{interpretation-in\_world(w2,interpretation-mapping(gets\_rich,\$o)),} \\
contains the information about the mappings for the {\tt gets\_rich} predicate in world {\tt w2}.

In the same way that Tarskian interpretation-formulae can be compacted, Kripke
interpretation-formulae can be compacted, e.g., by using universal quantification over the
worlds to factor out common elements of the Tarskian interpretations in the worlds.
Appendix~\ref{NXF_Finite-Finite-Global_Compact.s} shows a compacted version of
Appendix~\ref{NXF_Finite-Finite-Global.s}, in which the annotated formula~\ldots \\
\hspace*{0.5cm}\smalltt{tff(leo\_workers\_W\_product,} \\
\hspace*{0.8cm}\smalltt{interpretation-in\_world(W,interpretation-domain),} \\
contains the information about the domains that are the same in all worlds, and the 
annotated formula~\ldots \\
\hspace*{0.5cm}\smalltt{tff(leo\_workers\_W\_work\_hard,} \\
\hspace*{0.8cm}\smalltt{interpretation-in\_world(W,interpretation-mapping(work\_hard,\$o)),} \\
contains the mappings for the predicate symbol {\tt work\_hard} that are the same in all worlds.

%--------------------------------------------------------------------------------------------------
\subsection{Kripke Model Verification}
\label{KripkeVerification}

Kripke models written as interpretation-formulae can be verified using the theorem proving 
approach described in Section~\ref{Verification}.\footnote{%
To date we have done this for NXF problem formulae and TXF interpretation-formulae. 
Extension to NHF might be possible.}
An NXF verification problem is built from the NXF problem formulae and the TXF 
interpretation-formulae.
Although the verification problem includes the non-classical connectives in the problem
formulae, it is not necessary to provide a full logic specification (as in the problems in
Appendices~\ref{NXF_Finite-Finite-Global.p} and~\ref{NXF_Finite-Finite-Local.p}) because the
logical setting is captured in the interpretation-formulae.
The verification problem is thus not in the same logic as the problem formulae, but rather
some kind of hybrid logic~\cite{Bra11}, which is indicated by the special logic specification
value {\tt \$\$fomlModel}.
Appendix~\ref{NXF_Finite-Finite-Global.s.p} shows the NXF verification problem for the problem
in Appendix~\ref{NXF_Finite-Finite-Global.p} and its countermodel in
Appendix~\ref{NXF_Finite-Finite-Global.s}.
Appendix~\ref{NXF_Finite-Finite-Local.s.p} shows the NXF verification problem for the problem
in Appendix~\ref{NXF_Finite-Finite-Local.p} and its countermodel in
Appendix~\ref{NXF_Finite-Finite-Local.s}.

In the NXF verification problem the Kripke interpretation-formulae is given the {\tt axiom} role,
and each of the problem axioms and the negated problem conjecture are given the {\tt conjecture} 
role with a subrole of {\tt local} or {\tt global} according to their role in the problem, e.g., 
in Appendix~\ref{NXF_Finite-Finite-Global.p} the axiom of the problem~\ldots \\
\hspace*{0.5cm}\smalltt{tff(not\_all\_get\_rich,axiom,} \\
\hspace*{0.8cm}\smalltt{{\raisebox{0.4ex}{\texttildelow}}\,?\,[P:\,person]\,:\,(\,\{\$necessary\}\,@\,(gets\_rich(P))\,)\,).}\\
is global (the default), so the NXF verification conjecture in 
Appendix~\ref{NXF_Finite-Finite-Global.s.p} has the {\tt global} subrole~\ldots \\
\hspace*{0.5cm}\smalltt{tff(not\_all\_get\_rich,conjecture-global,} \\
\hspace*{0.8cm}\smalltt{{\raisebox{0.4ex}{\texttildelow}}\,?\,[P:\,person]\,:\,(\,\{\$necessary\}\,@\,(gets\_rich(P))\,)\,).} \\
The conjecture of the problem is local (the default)~\ldots \\
\hspace*{0.5cm}\smalltt{tff(only\_alex\_gets\_rich,conjecture,} \\
\hspace*{0.8cm}\smalltt{\{\$possible\}\,@\,(gets\_rich(alex)\,\&\,{\raisebox{0.4ex}{\texttildelow}}\,gets\_rich(chris)\,)\,).} \\
so the NXF verification (negated) conjecture has the {\tt local} subrole~\ldots \\
\hspace*{0.5cm}\smalltt{tff(only\_alex\_gets\_rich,conjecture-local,} \\
\hspace*{0.8cm}\smalltt{{\raisebox{0.4ex}{\texttildelow}}\,(\,\{\$possible\}\,@\,(\,gets\_rich(alex)\,\&\,{\raisebox{0.4ex}{\texttildelow}}\,gets\_rich(chris)\,)\,)\,).} \\

The NXF verification problem is embedded into TH0 using the NTFLET tool.
NTFLET recognizes the special logic specification and the new type and predicates, and combines
the NXF conjectures into a single TH0 conjecture.
The resultant TH0 problem is discharged using a trusted TH0 ATP system.

% \paragraph{Conversion to TXF:}~\\
% The new type and predicates, and the non-classical connectives in the problem, are expressed 
% in TXF, and the resultant TXF verification problem is discharged using a trusted TXF 
% ATP system.\footnote{%
% To date we have done this for alethic modal logic in NXF, which has the {\tt \$necessary} and 
% {\tt \$possible} connectives.
% Extension to NHF might be possible.}
% Appendix~\ref{NXF_Finite-Finite-Global.s.p} shows the verification problem for the problem
% in Appendix~\ref{NXF_Finite-Finite-Global.p} and its countermodel in 
% Appendix~\ref{NXF_Finite-Finite-Global.s}.
% Appendix~\ref{NXF_Finite-Finite-Local.s.p} shows the verification problem for the problem
% in Appendix~\ref{NXF_Finite-Finite-Local.p} and its countermodel in 
% Appendix~\ref{NXF_Finite-Finite-Local.s}.
% 
% The new type and predicates are converted to plain types and predicates by defining {\tt '}single 
% quoted{\tt '} versions of them, e.g., in TFF~\ldots \\
% \hspace*{0.5cm}\smalltt{tff(dollar\_world\_type,type,'\$world': \$tType).} \\
% \hspace*{0.5cm}\smalltt{tff(dollar\_accessible\_world\_decl,type,} \\
% \hspace*{0.8cm}\smalltt{'\$accessible\_world': ('\$world' * '\$world') > \$o).} \\
% \hspace*{0.5cm}\smalltt{tff(dollar\_local\_world\_decl,type, '\$local\_world': '\$world').} \\
% \hspace*{0.5cm}\smalltt{tff(dollar\_in\_world\_decl,type, '\$in\_world': ('\$world' * \$o) > \$o).} \\
% The modal connectives are redefined in {\tt '}single quotes{\tt '}, with a world as an additional
% argument~\ldots \\
% \hspace*{0.5cm}\smalltt{tff(dollar\_necessary\_decl,type, '\$necessary': ( '\$world' * \$o ) > \$o ).} \\
% \hspace*{0.5cm}\smalltt{tff(dollar\_possible\_decl,type, '\$possible': ( '\$world' * \$o ) > \$o ).} \\
% The meanings of the connectives are then axiomatized wrt a current world~\ldots
% \begin{packed_itemize}
% \item A formula is necessarily \textit{true} wrt the current world if it is \textit{true} wrt the interpretations
%       in all worlds that are accessible from the current world.
%       See the {\tt necessary\_defn} axiom in Appendices~\ref{NXF_Finite-Finite-Global.s.p}
%       and~\ref{NXF_Finite-Finite-Local.s.p}.
% \item A formula is possibly \textit{true} wrt the current world if it is \textit{true} wrt the interpretation
%       in some world that is accessible from the current world.
%       See the {\tt possible\_defn} axiom in Appendices~\ref{NXF_Finite-Finite-Global.s.p}
%       and~\ref{NXF_Finite-Finite-Local.s.p}.
% \item The duality of {\tt \$necessary} and {\tt \$possible} is axiomatized wrt worlds.
%       See the {\tt duality} axiom in Appendices~\ref{NXF_Finite-Finite-Global.s.p}
%       and~\ref{NXF_Finite-Finite-Local.s.p}.
% \end{packed_itemize}
% 
% The verification problem has the connective axioms and the Kripke interpretation-formulae 
% (with the type and predicates {\tt '}quoted{\tt '}) as axioms.
% The problem axioms and negated conjecture (with the modal connectives {\tt '}quoted{\tt '})
% are proved.
% Global (the default) axioms and global (specified with the {\tt conjecture-local} role)
% negated conjectures are proved in all worlds' interpretations, e.g., in 
% Appendix~\ref{NXF_Finite-Finite-Global.s.p} the axioms are all global, and are proved in
% all worlds' interpretations by universal quantification over the worlds~\ldots \\
% \hspace*{0.5cm}\smalltt{! [W: '\$world'] : ? [I: \$o] : ( '\$in\_world'(W,(I)) \& ( (I) =>} \\
% Note how the world is provided as an additional argument to the {\tt '}quoted{\tt '} modal
% connectives, e.g., in Appendix~\ref{NXF_Finite-Finite-Global.s.p}~\ldots \\
% \hspace*{0.5cm}\smalltt{’\$possible’(W,gets\_rich(P))} \\
% Local (specified with the {\tt axiom-local} role) axioms and local (the default) negated
% conjectures are proved in the local world's interpretation, e.g., 
% in Appendix~\ref{NXF_Finite-Finite-Local.s.p} the local axiom {\tt rotten(banana)} and
% the conjecture are proved in the local world's interpretation~\ldots \\
% \hspace*{0.5cm}\smalltt{? [I: \$o] : ( '\$in\_world'('\$local\_world',(I)) \& ( (I) =>} \\
% Note how the local world is provided as an additional argument to the {\tt '}quoted{\tt '} 
% modal connectives, e.g., in Appendix~\ref{NXF_Finite-Finite-Local.s.p}~\ldots \\
% \hspace*{0.5cm}\smalltt{'\$necessary'('\$local\_world',( healthy(apple) \& ~ rotten(banana) ))}

%--------------------------------------------------------------------------------------------------
\section{Conclusion}
\label{Conclusion}

This paper describes the new TPTP format for representing interpretations.
It provides a background survey that helped us ensure that the representation format is adequate
for different types of interpretations, including Tarskian, Herbrand, and Kripke interpretations.
Some tools that support processing the new format have been noted.

The new TPTP format provides very many options and features, and it is expected that only the 
basic features will be adopted initially. 
For ATP systems that already output the old TPTP format for finite Tarskian interpretations
all that is needed is to replace the {\tt fi\_domain}, {\tt fi\_functors}, and {\tt fi\_predicates}
roles by {\tt interpretation}. 
To be more informative, {\tt fi\_domain} can be replaced by by {\tt interpretation-domain}, and 
{\tt fi\_functors} and {\tt fi\_predicates} can be replaced by {\tt interpretation\-mapping}.

Section~\ref{Need} listed four needs for interpretations: 
\begin{packed_itemize}
\item Evaluability - the ability to evaluate a formula wrt an interpretation.
\item Tractability - the ability to evaluate a formula using some limited/reasonable amount of
      resources.
\item Verifiability - the ability to verify a model by evaluating all the formulae it claims
      to model as \textit{true}.
\item Comprehensibility - be understandable, typically by a human but possibly by a machine.
\end{packed_itemize}

In the light of the above (and hey, maybe there are more techniques than just those) I claim~\ldots
\begin{packed_itemize}
\item Finite interpretations represented by interpretation-formulae are typically evaluable,
      tractable, verifiable, and comprehensible.
\item Infinite interpretations represented by interpretation-formulae are evaluable, often 
      intractable, verifiable, and might not be comprehensible.
\item HI-formulae (in interpretation-formulae) are evaluable, can be tractable, verifiable, 
      and can be comprehensible.
\item Saturations (in interpretation-formulae) are evaluable, often intractable, verifiable, 
      and almost always incomprehensible.
\item The verifiability, tractability, and comprehensibility of Kripke interpretations varies
      between individual cases.
\item Use of the same language as the problem formulae for writing interpretation-formulae
      contributes to comprehensibility (but does not ensure it).
\end{packed_itemize}

This work will be extended to deal with more non-classical languages.
But for now we are pausing to allow ATP system developers to react to the format, which might 
lead to improvements, and hopefully will lead to them implementing the format in the ATP systems.

%--------------------------------------------------------------------------------------------------
% Not needed for CEUR 
\bibliographystyle{plain}
\bibliography{Bibliography.bib}
%--------------------------------------------------------------------------------------------------
\appendix

\newpage
\section{FOF}
\label{FOF}

\subsection{FOF Problem with a Finite Countermodel
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/FOF_Finite.p}{Online})}
\label{FOF_Finite.p}
\begin{small}
\verbatiminput{Examples/FOF_Finite.p}
\end{small}

\newpage
\subsection{FOF Finite Model for \ref{FOF_Finite.p}, Coarse Grained
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/FOF_Finite.s}{Online})}
\label{FOF_Finite.s}
\begin{small}
\verbatiminput{Examples/FOF_Finite.s}
\end{small}

\newpage
\subsection{FOF Verification Problem for \ref{FOF_Finite.p} and \ref{FOF_Finite.s}
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/FOF_Finite.s.p}{Online})}
\label{FOF_Finite.s.p}
\begin{small}
\verbatiminput{Examples/FOF_Finite.s.p}
\end{small}

\newpage
\subsection{FOF Finite Model for \ref{FOF_Finite.p}, Medium Grained
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/FOF_Finite_Medium.s}{Online})}
\label{FOF_Finite_Medium.s}
\begin{small}
\verbatiminput{Examples/FOF_Finite_Medium.s}
\end{small}

\newpage
\subsection{FOF Finite Model for \ref{FOF_Finite.p}, Fine Grained
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/FOF_Finite_Fine.s}{Online})}
\label{FOF_Finite_Fine.s}
\begin{small}
\verbatiminput{Examples/FOF_Finite_Fine.s}
\end{small}

\newpage
\subsection{FOF Formula Model for \ref{FOF_Finite.p}
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/FOF_Formulae.s}{Online})}
\label{FOF_Formulae.s}
\begin{small}
\verbatiminput{Examples/FOF_Formulae.s}
\end{small}

\newpage
\subsection{FOF Saturation for \ref{FOF_Finite.p}
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/FOF_Saturation.s}{Online})}
\label{FOF_Saturation.s}
\begin{small}
\verbatiminput{Examples/FOF_Saturation.s}
\end{small}

\newpage
\subsection{FOF Verification Problem for \ref{FOF_Finite.p} and \ref{FOF_Formulae.s}
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/FOF_Formulae.s.p}{Online})}
\label{FOF_Formulae.s.p}
\begin{small}
\verbatiminput{Examples/FOF_Formulae.s.p}
\end{small}

\newpage
\subsection{FOF Verification Problem for \ref{FOF_Finite.p} and \ref{FOF_Saturation.s}
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/FOF_Saturation.s.p}{Online})}
\label{FOF_Saturation.s.p}
\begin{small}
\verbatiminput{Examples/FOF_Saturation.s.p}
\end{small}

%--------------------------------------------------------------------------------------------------
\newpage
\section{TF0, Finite Interpretations}
\label{TF0Finite}

\subsection{TF0 Problem with a Finite Countermodel
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/TFF_Finite.p}{Online})}
\label{TFF_Finite.p}
\begin{small}
\verbatiminput{Examples/TFF_Finite.p}
\end{small}

\newpage
\subsection{TF0 Finite Model for \ref{TFF_Finite.p}, Reusing Problem Types
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/TFF_Finite.s}{Online})}
\label{TFF_Finite.s}
\begin{small}
\verbatiminput{Examples/TFF_Finite.s}
\end{small}

\newpage
\subsection{TF0 Verification Problem for \ref{TFF_Finite.p} and \ref{TFF_Finite.s}
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/TFF_Finite.s.p}{Online})}
\label{TFF_Finite.s.p}
\begin{small}
\verbatiminput{Examples/TFF_Finite.s.p}
\end{small}

\newpage
\subsection{TF0 Finite Model for \ref{TFF_Finite.p}, Separate Domain Types
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/TFF_Finite_SeparateDomains.s}{Online})}
\label{TFF_Finite_SeparateDomains.s}
\begin{small}
\verbatiminput{Examples/TFF_Finite_SeparateDomains.s}
\end{small}

\newpage
\subsection{TF0 Verification Problem for \ref{TFF_Finite.p} and \ref{TFF_Finite_SeparateDomains.s}
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/TFF_Finite_SeparateDomains.s.p}{Online})}
\label{TFF_Finite_SeparateDomains.s.p}
\begin{small}
\verbatiminput{Examples/TFF_Finite_SeparateDomains.s.p}
\end{small}

\newpage
\subsection{TF0 Finite Model for \ref{TFF_Finite.p}, Medium Grained
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/TFF_Finite_Medium.s}{Online})}
\label{TFF_Finite_Medium.s}
\begin{small}
\verbatiminput{Examples/TFF_Finite_Medium.s}
\end{small}

\newpage
\subsection{TF0 Finite Model for \ref{TFF_Finite.p}, Fine Grained
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/TFF_Finite_Fine.s}{Online})}
\label{TFF_Finite_Fine.s}
\begin{small}
\verbatiminput{Examples/TFF_Finite_Fine.s}
\end{small}

\newpage
\subsection{TF0 Finite Model for \ref{TFF_Finite.p}, Compacted
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/TFF_Finite_Compact.s}{Online})}
\label{TFF_Finite_Compact.s}
\begin{small}
\verbatiminput{Examples/TFF_Finite_Compact.s}
\end{small}

%--------------------------------------------------------------------------------------------------
\newpage
\section{TF0, Infinite Interpretations}
\label{TF0Infinite}

\subsection{TF0 Axioms with an Infinite Model
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/TFF_Infinite.p}{Online})}
\label{TFF_Infinite.p}
\begin{small}
\verbatiminput{Examples/TFF_Infinite.p}
\end{small}

\newpage
\subsection{TF0 Infinite Model for \ref{TFF_Infinite.p}, Term Domain
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/TFF_Peano.s}{Online})}
\label{TFF_Peano.s}
\begin{small}
\verbatiminput{Examples/TFF_Peano.s}
\end{small}

\newpage
\subsection{TF0 Infinite Model for \ref{TFF_Infinite.p}, Integer Domain
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/TFF_Integer.s}{Online})}
\label{TFF_Integer.s}
\begin{small}
\verbatiminput{Examples/TFF_Integer.s}
\end{small}

\newpage
\subsection{TF0 Verification Problem for \ref{TFF_Infinite.p} and \ref{TFF_Peano.s}
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/TFF_Peano.s.p}{Online})}
\label{TFF_Peano.s.p}
\begin{small}
\verbatiminput{Examples/TFF_Peano.s.p}
\end{small}

\newpage
\subsection{TF0 Verification Problem for \ref{TFF_Infinite.p} and \ref{TFF_Integer.s}
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/TFF_Integer.s.p}{Online})}
\label{TFF_Integer.s.p}
\begin{small}
\verbatiminput{Examples/TFF_Integer.s.p}
\end{small}

%--------------------------------------------------------------------------------------------------
\newpage
\section{TH0, Finite Interpretations}
\label{TH0Finite}

\subsection{TH0 Problem with a Finite Countermodel
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/THF_Finite.p}{Online})}
\label{THF_Finite.p}
\begin{small}
\verbatiminput{Examples/THF_Finite.p}
\end{small}

\newpage
\subsection{TH0 Finite Model for \ref{THF_Finite.p}, Coarse Grained
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/THF_Finite.s}{Online})}
\label{THF_Finite.s}
\begin{small}
\verbatiminput{Examples/THF_Finite.s}
\end{small}

\newpage
\subsection{TH0 Verification Problem for \ref{THF_Finite.p} and \ref{THF_Finite.s}
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/THF_Finite.s.p}{Online})}
\label{THF_Finite.s.p}
\begin{small}
\verbatiminput{Examples/THF_Finite.s.p}
\end{small}

\newpage
\subsection{TH0 Finite Model for \ref{THF_Finite.p}, Mixed Grained
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/THF_Finite_Medium.s}{Online})}
\label{THF_Finite_Medium.s}
\begin{small}
\verbatiminput{Examples/THF_Finite_Medium.s}
\end{small}

\newpage
\subsection{TH0 Finite Model for \ref{THF_Finite.p}, Compacted
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/THF_Finite_Compact.s}{Online})}
\label{THF_Finite_Compact.s}
\begin{small}
\verbatiminput{Examples/THF_Finite_Compact.s}
\end{small}

%--------------------------------------------------------------------------------------------------
\newpage
\section{NXF, Finite Worlds with Finite Interpretations}
\label{NXF}

\subsection{NXF Problem with Global Axioms, \\ with a Finite-Finite Countermodel
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/NXF_Finite-Finite-Global.p}{Online})}
\label{NXF_Finite-Finite-Global.p}
\begin{small}
\verbatiminput{Examples/NXF_Finite-Finite-Global.p}
\end{small}

\newpage
\subsection{TXF Finite-Finite Model for \ref{NXF_Finite-Finite-Global.p}
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/NXF_Finite-Finite-Global.s}{Online})}
\label{NXF_Finite-Finite-Global.s}
\begin{small}
\verbatiminput{Examples/NXF_Finite-Finite-Global.s}
\end{small}

\newpage
\subsection{NXF Verification Problem for \ref{NXF_Finite-Finite-Global.p} and 
\ref{NXF_Finite-Finite-Global.s}
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/NXF_Finite-Finite-Global.s.p}{Online})}
\label{NXF_Finite-Finite-Global.s.p}
\begin{small}
\verbatiminput{Examples/NXF_Finite-Finite-Global.s.p}
\end{small}

% \newpage
% \subsection{TXF Verification Problem for \ref{NXF_Finite-Finite-Global.p} and 
% \ref{NXF_Finite-Finite-Global.s}
% (\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/NXF_Finite-Finite-Global.s.TXF.p}{Online})}
% \label{NXF_Finite-Finite-Global.s.TXF.p}
% \begin{small}
% \verbatiminput{Examples/NXF_Finite-Finite-Global.s.TXF.p}
% \end{small}

\newpage
\subsection{NXF Problem with Global and Local Axioms, \\
            with a Finite-Finite Countermodel
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/NXF_Finite-Finite-Local.p}{Online})}
\label{NXF_Finite-Finite-Local.p}
\begin{small}
\verbatiminput{Examples/NXF_Finite-Finite-Local.p}
\end{small}

\newpage
\subsection{TXF Finite-Finite Model for \ref{NXF_Finite-Finite-Local.p}
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/NXF_Finite-Finite-Local.s}{Online})}
\label{NXF_Finite-Finite-Local.s}
\begin{small}
\verbatiminput{Examples/NXF_Finite-Finite-Local.s}
\end{small}

\newpage
\subsection{NXF Verification Problem for \ref{NXF_Finite-Finite-Local.p} and
\ref{NXF_Finite-Finite-Local.s}
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/NXF_Finite-Finite-Local.s.p}{Online})}
\label{NXF_Finite-Finite-Local.s.p}
\begin{small}
\verbatiminput{Examples/NXF_Finite-Finite-Local.s.p}
\end{small}

% \newpage
% \subsection{TXF Verification Problem for \ref{NXF_Finite-Finite-Local.p} and
% \ref{NXF_Finite-Finite-Local.s}
% (\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/NXF_Finite-Finite-Local.s.TXF.p}{Online})}
% \label{NXF_Finite-Finite-Local.s.TXF.p}
% \begin{small}
% \verbatiminput{Examples/NXF_Finite-Finite-Local.s.TXF.p}
% \end{small}

\newpage
\subsection{TXF Finite-Finite Model for \ref{NXF_Finite-Finite-Global.p}, Medium Grained \\
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/NXF_Finite-Finite-Global_Medium.s}{Online})}
\label{NXF_Finite-Finite-Global_Medium.s}
\begin{small}
\verbatiminput{Examples/NXF_Finite-Finite-Global_Medium.s}
\end{small}

\newpage
\subsection{TXF Finite-Finite Model for \ref{NXF_Finite-Finite-Global.p}, Fine Grained
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/NXF_Finite-Finite-Global_Fine.s}{Online})}
\label{NXF_Finite-Finite-Global_Fine.s}
\begin{small}
\verbatiminput{Examples/NXF_Finite-Finite-Global_Fine.s}
\end{small}

\newpage
\subsection{TXF Finite-Finite Model for \ref{NXF_Finite-Finite-Global.p}, Compacted
(\href{https://raw.githubusercontent.com/GeoffsPapers/InterpretationFormat/master/Examples/NXF_Finite-Finite-Global_Compact.s}{Online})}
\label{NXF_Finite-Finite-Global_Compact.s}
\begin{small}
\verbatiminput{Examples/NXF_Finite-Finite-Global_Compact.s}
\end{small}

%--------------------------------------------------------------------------------------------------
\end{document}
%--------------------------------------------------------------------------------------------------
